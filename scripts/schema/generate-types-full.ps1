# ========================================
# Generate TypeScript Types from FULL Schema
# Uses introspectionSchema-FULL.json (complete field definitions)
# ========================================

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "TypeScript Type Generator (FULL SCHEMA)" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host ""

# Load FULL schema with field definitions
$schemaFile = (Join-Path $PSScriptRoot "..\\..\\.github\\introspectionSchema-FULL.json")
if (-not (Test-Path $schemaFile)) {
	Write-Host "[FAIL] Schema file not found: $schemaFile" -ForegroundColor Red
	Write-Host "[INFO] Run .\\scripts\\schema\\download-full-schema.ps1 first!" -ForegroundColor Yellow
	exit 1
}

Write-Host "[INFO] Loading $schemaFile..." -ForegroundColor Cyan
$schema = Get-Content $schemaFile -Raw | ConvertFrom-Json
$types = $schema.__schema.types

Write-Host "[OK] Schema loaded" -ForegroundColor Green
Write-Host "  Total types: $($types.Count)" -ForegroundColor Gray
Write-Host ""

# Output file
$outputFile = (Join-Path $PSScriptRoot "..\\..\\src\\sitecore-types-FULL.ts")

# Start building TypeScript file
$tsContent = @"
/**
 * Sitecore GraphQL TypeScript Type Definitions
 * AUTO-GENERATED from introspectionSchema-FULL.json
 * Generated: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
 * 
 * Source: .github\\introspectionSchema-FULL.json
 * Total types: $($types.Count)
 * 
 * DO NOT EDIT THIS FILE MANUALLY!
 * Run: .\\scripts\\schema\\generate-types-full.ps1 to regenerate
 */

// ============================================
// SCALAR TYPES
// ============================================

export type ID = string;
export type String = string;
export type Boolean = boolean;
export type Int = number;
export type Float = number;
export type Date = string;
export type DateTime = string;
export type DateTimeOffset = string;
export type Seconds = number;
export type Milliseconds = number;
export type Decimal = number;
export type JSON = any;

"@

# Helper function to convert GraphQL type to TypeScript
function Convert-GraphQLTypeToTS {
	param($type, $depth = 0)
    
	if ($depth -gt 7) { return "any" }
    
	if ($type.kind -eq "NON_NULL") {
		return Convert-GraphQLTypeToTS $type.ofType ($depth + 1)
	}
	elseif ($type.kind -eq "LIST") {
		$innerType = Convert-GraphQLTypeToTS $type.ofType ($depth + 1)
		return "$innerType[]"
	}
	elseif ($type.kind -eq "SCALAR") {
		switch ($type.name) {
			"String" { return "string" }
			"Int" { return "number" }
			"Float" { return "number" }
			"Boolean" { return "boolean" }
			"ID" { return "ID" }
			"Date" { return "string" }
			"DateTime" { return "string" }
			"DateTimeOffset" { return "string" }
			"Seconds" { return "number" }
			"Milliseconds" { return "number" }
			"Decimal" { return "number" }
			"JSON" { return "any" }
			default { return "any" }
		}
	}
	else {
		return $type.name
	}
}

# Core types to extract
$coreTypeNames = @(
	'Query',
	'Mutation',
	'Item',
	'ItemTemplate',
	'ItemTemplateField',
	'ItemField',
	'ItemLanguage',
	'ItemAccess',
	'ItemWorkflow',
	'ItemWorkflowState',
	'InsertOptions',
	'TextField',
	'DateField',
	'ImageField',
	'LinkField',
	'FileField',
	'CheckboxField',
	'IntegerField',
	'NumberField',
	'MultilistField',
	'LookupField',
	'ReferenceField',
	'LayoutField',
	'LayoutFieldDevice',
	'LayoutFieldRendering',
	'NameValueListField',
	'NameValueListValue',
	'ContentSearchResults',
	'ContentSearchResultConnection',
	'ContentSearchResult',
	'ContentSearchResultEdge',
	'ContentSearchFacet',
	'ContentSearchFacetValue',
	'ContentSearchFieldValue',
	'PageInfo',
	'SiteGraphType'
)

Write-Host "[INFO] Generating TypeScript interfaces..." -ForegroundColor Cyan
Write-Host ""

$generated = 0

foreach ($typeName in $coreTypeNames) {
	$type = $types | Where-Object { $_.name -eq $typeName }
    
	if (-not $type) {
		Write-Host "  [SKIP] $typeName (not found)" -ForegroundColor Yellow
		continue
	}
    
	if ($type.kind -eq "INTERFACE" -or $type.kind -eq "OBJECT") {
		Write-Host "  [GEN] $typeName ($($type.kind))" -ForegroundColor Green
        
		$tsContent += "`n// ============================================`n"
		$tsContent += "// $typeName`n"
		$tsContent += "// Kind: $($type.kind)`n"
		if ($type.description) {
			$tsContent += "// Description: $($type.description)`n"
		}
		if ($type.fields) {
			$tsContent += "// Fields: $($type.fields.Count)`n"
		}
		if ($type.interfaces -and $type.interfaces.Count -gt 0) {
			$interfaces = $type.interfaces | ForEach-Object { $_.name }
			$tsContent += "// Implements: $($interfaces -join ', ')`n"
		}
		$tsContent += "// ============================================`n`n"
        
		$tsContent += "export interface $typeName {`n"
        
		if ($type.fields) {
			foreach ($field in $type.fields) {
				$fieldType = Convert-GraphQLTypeToTS $field.type
				$optional = if ($field.type.kind -ne "NON_NULL") { "?" } else { "" }
                
				if ($field.description) {
					$tsContent += "  /** $($field.description) */`n"
				}
                
				# Check if field has arguments
				if ($field.args -and $field.args.Count -gt 0) {
					$argStr = "/* args: "
					$argList = @()
					foreach ($arg in $field.args) {
						$argType = Convert-GraphQLTypeToTS $arg.type
						$argList += "$($arg.name): $argType"
					}
					$argStr += $argList -join ', '
					$argStr += " */"
					$line = "  $($field.name)$($optional)$($argStr): $($fieldType);`n"
					$tsContent += $line
				} else {
					$line = "  $($field.name)$($optional): $($fieldType);`n"
					$tsContent += $line
				}
			}
		}
        
		$tsContent += "}`n"
		$generated++
	}
	elseif ($type.kind -eq "ENUM") {
		Write-Host "  [GEN] $typeName (ENUM)" -ForegroundColor Green
        
		$tsContent += "`n// ============================================`n"
		$tsContent += "// $typeName (ENUM)`n"
		$tsContent += "// ============================================`n`n"
        
		$tsContent += "export enum $typeName {`n"
        
		if ($type.enumValues) {
			foreach ($enumValue in $type.enumValues) {
				if ($enumValue.description) {
					$tsContent += "  /** $($enumValue.description) */`n"
				}
				$tsContent += "  $($enumValue.name) = \"$($enumValue.name)\",`n"
			}
		}
        
		$tsContent += "}`n"
		$generated++
	}
}

# Add helper types at the end
$tsContent += @"

// ============================================
// HELPER TYPES
// ============================================

/**
 * MCP Tool Response wrapper
 */
export interface MCPToolResponse<T = any> {
  content: Array<{
	type: "text";
	text: string;
  }>;
  data?: T;
}

/**
 * Field discovery response
 */
export interface FieldDiscoveryResponse {
  totalFields: number;
  fields: Array<{
	name: string;
	value?: any;
	type?: string;
  }>;
}

/**
 * Version info response
 */
export interface VersionInfoResponse {
  version: number;
  versionCount: number;
}

// ============================================
// EXPORT ALL
// (interfaces already exported above)
// ============================================
"@

# Save to file
$tsContent | Set-Content $outputFile -Encoding UTF8

Write-Host ""
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "Generation Complete" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "Generated: $generated types" -ForegroundColor Green
Write-Host "Output: $outputFile" -ForegroundColor Cyan
Write-Host ""

$fileInfo = Get-Item $outputFile
Write-Host "File size: $([math]::Round($fileInfo.Length / 1KB, 2)) KB" -ForegroundColor Gray
Write-Host "Lines: $((Get-Content $outputFile).Count)" -ForegroundColor Gray
Write-Host ""

Write-Host "[SUCCESS] TypeScript types generated!" -ForegroundColor Green